# ЗАДАЧА ТОРГОВЫЕ АВТОМАТЫ.ЗАКАЗЫ

SOLID Принципы. Принципы ООП.

2) С целью следования принципу Single ResponsibilityPrinciple из AutomatController выношу метод BestProduct и новый контроллер BestProductController, метод поиска заказа по имени - в новый контроллер GetOrderController

3) С целью следования Open-closedPrinciple Делаю наследников класса Automat и переопределяю в них метод GetProduct добавляя в него новые аргументы.

4) С целью следования Interface segregation principle не добавляю лишние методы в AbsctactRepository, выношу их в отдельные интерфейсы от которых наследуются репозитории. В сервисах в интерфейсе задаю нужные методы и перепоределяю их в классах.

ОБЩЕЕ ОПИСАНИЕ РЕШЕНИЯ

1) МОДЕЛИ

В проекте выделены три сущности - товары (абстрактный класс Product), Торговые автоматы (абстрактный класс Automat) и заказы (класс Order). Все сущности представлены в папке models.

Представлено три вида торговых автоматов (наследники Automat) - напитков и закусок (DrinkSnackAutomat), горячих напитков (HotDrinkAutomat) и игрушек (GameAutomat).

Три вида продуктов (наследники Product) - 1) напитки и закуски (DrinkSnackProduct), от него наследники напитки (Drink) и закуски (Snack). 2) Горячие напитки (HotDrinkProduct). 3) игры (GameProduct).

У продуктов поля - id, name, price. У напитков (Drink) добавляется volume, у закусок - масса (weight). У горячих напитков - температура и объём

Абстрактный класс ProductsSet определяет общие для заказа и автомата функции и поля - id, size, productsList (продукт и количество), геттеры и сеттеры, абстрактный метод AddProduct.

Заказы (Order) не имеют наследников, добавляется поле code (определяется рандомно число от 100 до 1000), automat (торговый автомат в котором сделан заказ).

В классах переопределяется метод toString в котором представлены все поля класса.

В Automat и Order метод AddProduct добавляет продукт в список продуктов и его количество из переданного в аргументы product и num. В Automat дополнительно сравнивает количество введенного товара с его вместимостью. В order - что в автомате достаточно таких продуктов

В торговом автомате (Automat) есть метод поиска товара по id (getProductById) и по имени (getProduct), который переопределяется в классах наследниках новыми полями.

В моделях создан интерфейс ComparableProduct, в котором задан абстрактный метод getAttractiveness(), задающий необходимость для каждого продукта определить этот метод.

Абстрактный класс Product имплементирует интерфейс ComparableProduct. В этом классе добавляется поле attractiveness и определён метод compareTo() для двух продуктов между собой - текущего и переданного в аргументы.

В классах DrinkSnackProduct, GameProduct и HotDrinkProduct определён метод getAttractiveness() который определяет параметр сравнивания каждого вида продукта. В первых двух по цене, в третьем по температуре.

2.VIEW

Абстрактный класс View имеет boolean поле error (ошибка или нет) и сообщение об ошибке errorMessage.

В каждом из этих классов-наследников (AutomatView, OrderView) есть метод printSetList и printProductList который печатает список товаров, торговых автоматов или заказов соответственно. Если поле error говорит об ошибке - печатает сообщение об ошибке, в противном случае - список заказов товаров и торговых автоматов.

3. REPOSITORY

Представлены общий абстрактный класс дженерик AbstractRepository, в нём методы getProductSetById находят определенный в дженерике класс (заказ или автомат) по имени или id, метод AddProductSet добавляет переданный в аргументе заказ или автомат. Для его наследника репозитория AutomatRepository задан метод getAutomatByName, для OrderRepository - getOrderByCode.

4. SERVICE

Классы для объединения репозиториев и view.

Представлены общий абстрактный класс дженерик ServiceInterface задаёт методы используя определенные в дженерике объекты. Наследники переопределяют эти классы (AutomatService, OrderSService). Метод AddInRepository добавляет в репозиторий, GetById ищет объект по id, GetProductSets выводит все объекты в репозитории, GetProductList выводит все товары в объекте.

BestProductService класс для определения лучшего продукта в автомате

5. CONTROLLERS

Представлены два класса - AutomatController и OrderController.

В AutomatController в конструктор передается AutomatService, пользователю выводится список торговых автоматов и предлагается выбрать его для заказа, проверяется есть ли выбранный торговый автомат в репозитории. Если нет - предлагается снова выбрать, если есть - метод возвращает этот торговый автомат.

OrderController в конструктор передаётся торговый автомат. Создаётся новый заказ (new Order), ему в конструктор передаётся торговый автомат. Задан массив номеров продуктов. Цикл проходит по массиву.

Метод doOrder В этом методе ищется продукт в торговом автомате по id. Если в автомате есть товар - проверяется, добавлен ли продукт в заказ. Продукт в заказ не добавлен - добавляется товар и его количество равно единице. Если продукт в заказ добавлен - проверяется не превышает ли количество добавленных продуктов (if(order.AddProduct)) их количество в торговом автомате. Если не превышает - увеличивается число добавленого товара, если превышает - выводится ошибка об этом и цикл переходит к следующему элементу.

Если заказ не пустой - заказ добавляется в репозиторий заказов, выводится список заказов - его id и код, и выводится текущий заказ. Если заказ пустой - печатается сообщение об этом.

GetOrderController получает в конструктор OrderService. Метод GetOrderByCode в GetOrderController выводит список заказов в репозитории, ищет заказ с указанным кодом в репозитории и выводит список товаров в нём.

Для поиска лучшего товара в торговом автомате в BestProuctService определён метод getBestProduct принимающий в аргументы торговый автомат. Определяется список продуктов в этом автомате и циклом находятся лучший.

6. MAIN

создаются экземпляры товаров и торговых автоматов, в торговые аппараты добавляются товары и их количество, создается AutomatService и с его помощью торговые автоматы добавляются в репозиторий, экземпляры контроллеров в которые передаются соответствующие сервисы, и вызываются методы контроллеров.
